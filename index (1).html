<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCO - Room 3: World Map</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden; background-color: #0a1520;
            font-family: 'Great Vibes', cursive;
        }

        #webgl-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        
        #css-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
        }

        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #c9a227; text-transform: uppercase; letter-spacing: 0.2em;
            font-size: 1rem; z-index: 10; transition: opacity 0.5s ease-out;
            text-shadow: 0 0 10px rgba(201, 162, 39, 0.6);
            pointer-events: none;
            font-family: serif;
        }

        .map-label {
            background: linear-gradient(to bottom, #d4a574, #b8906a);
            color: #3d2817;
            padding: 4px 12px;
            border-radius: 3px;
            border: 1px solid #8b6914;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            font-family: 'Great Vibes', cursive;
            font-size: 22px;
            font-weight: 400;
            text-align: center;
            white-space: nowrap;
            pointer-events: auto;
            cursor: pointer;
        }

        #snow-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 3;
        }
    </style>
</head>
<body>

    <div id="loader">Entering the Chamber...</div>
    <canvas id="snow-overlay"></canvas>
    <div id="css-container"></div>
    <div id="webgl-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, cssRenderer, composer, controls;
        const gltfLoader = new GLTFLoader();

        // Shopify CDN Assets (CORS enabled)
        const ASSETS = {
            volcano: 'https://cdn.shopify.com/3d/models/f924502a9103fb87/volcano.glb',
            cottage: 'https://cdn.shopify.com/3d/models/6411e285021f955c/cottage.glb',
            rock: 'https://cdn.shopify.com/3d/models/18338322fe021095/rockcluster.glb',
            ice: 'https://cdn.shopify.com/3d/models/df3172d196d78153/ice_shard_crystal_obelisk_.glb',
            tree: 'https://cdn.shopify.com/3d/models/2cb6f5740f9e5af7/dead_tree_dry_tree_spooky_tree_.glb',
            tower: 'https://cdn.shopify.com/3d/models/3968786b5cf2e917/watch_tower_castle_.glb'
        };

        let mapGroup;
        let loadedCount = 0;
        const totalAssets = 6;

        init();
        animate();
        initSnow();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1520);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(-8, 3, 18);
            camera.lookAt(5, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            document.getElementById('webgl-container').appendChild(renderer.domElement);

            cssRenderer = new CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('css-container').appendChild(cssRenderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.4, 0.85
            );
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, cssRenderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 40;
            controls.target.set(5, 0, 0);

            setupLighting();
            createCaveWalls();
            createStairs();
            createMirrorWithMap();
            createFloorRunes();
            
            mapGroup = new THREE.Group();
            mapGroup.position.set(5, 0, 0.8);
            scene.add(mapGroup);
            
            loadAllGLBs();
            addMapLabels();

            window.addEventListener('resize', onWindowResize);
        }

        function setupLighting() {
            scene.add(new THREE.PointLight(0x00dddd, 2.5, 30).copy({ position: new THREE.Vector3(-12, 3, 8) }) || (() => {
                const l = new THREE.PointLight(0x00dddd, 2.5, 30);
                l.position.set(-12, 3, 8);
                return l;
            })());
            
            const cyanLight = new THREE.PointLight(0x00dddd, 2.5, 30);
            cyanLight.position.set(-12, 3, 8);
            scene.add(cyanLight);

            const warmLight = new THREE.SpotLight(0xffeecc, 1.5, 25, Math.PI / 3, 0.5);
            warmLight.position.set(5, 12, 8);
            warmLight.target.position.set(5, 0, 0);
            scene.add(warmLight);
            scene.add(warmLight.target);

            scene.add(new THREE.AmbientLight(0x1a2530, 0.6));

            const backLight = new THREE.DirectionalLight(0x223344, 0.4);
            backLight.position.set(0, 5, -10);
            scene.add(backLight);
        }

        function createCaveWalls() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x1e2d3d, roughness: 0.9, flatShading: true });

            // Left rocks
            for (let i = 0; i < 12; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5 + Math.random() * 2.5, 1), wallMat);
                rock.position.set(-10 - Math.random() * 5, -2 + Math.random() * 8, -5 + Math.random() * 15);
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(rock);
            }

            // Back rocks
            for (let i = 0; i < 8; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2 + Math.random() * 3, 1), wallMat);
                rock.position.set(-5 + Math.random() * 20, -2 + Math.random() * 10, -12 - Math.random() * 5);
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(rock);
            }

            // Floor rocks
            for (let i = 0; i < 6; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5 + Math.random(), 0), wallMat);
                rock.position.set(2 + Math.random() * 8, -4.5, -2 + Math.random() * 5);
                rock.scale.y = 0.5;
                scene.add(rock);
            }

            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(60, 60),
                new THREE.MeshStandardMaterial({ color: 0x151f28, roughness: 0.9 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -5;
            scene.add(floor);

            // Ice crystals
            const iceMat = new THREE.MeshStandardMaterial({
                color: 0x40e0d0, emissive: 0x00aaaa, emissiveIntensity: 0.4,
                roughness: 0.1, transparent: true, opacity: 0.85
            });
            for (let i = 0; i < 4; i++) {
                const ice = new THREE.Mesh(new THREE.ConeGeometry(0.4 + Math.random() * 0.5, 2 + Math.random() * 3, 5), iceMat);
                ice.position.set(-10 + Math.random() * 2, -4 + i * 1.2, 6 + Math.random() * 3);
                ice.rotation.z = (Math.random() - 0.5) * 0.3;
                scene.add(ice);
            }
        }

        function createStairs() {
            const stairMat = new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.85, flatShading: true });
            for (let i = 0; i < 6; i++) {
                const step = new THREE.Mesh(new THREE.BoxGeometry(4, 0.6, 2), stairMat);
                step.position.set(-8 - i * 1.2, -4.5 + i * 0.7, 6);
                step.rotation.y = 0.1;
                scene.add(step);
            }
        }

        function createMirrorWithMap() {
            const frameGroup = new THREE.Group();
            frameGroup.position.set(5, 0, 0);

            const frameMat = new THREE.MeshStandardMaterial({ color: 0xc9a227, roughness: 0.35, metalness: 0.85 });

            const frame = new THREE.Mesh(new THREE.TorusGeometry(5, 0.6, 16, 64), frameMat);
            frame.scale.set(1, 1.3, 1);
            frameGroup.add(frame);

            const innerFrame = new THREE.Mesh(new THREE.TorusGeometry(4.6, 0.2, 12, 64), frameMat);
            innerFrame.scale.set(1, 1.3, 1);
            innerFrame.position.z = 0.2;
            frameGroup.add(innerFrame);

            const topOrn = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), frameMat);
            topOrn.position.set(0, 7, 0);
            topOrn.scale.set(1.3, 0.9, 0.5);
            frameGroup.add(topOrn);

            const runeMat = new THREE.MeshBasicMaterial({ color: 0xaaddff });
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const rune = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.08), runeMat);
                rune.position.set(5.4 * Math.cos(angle), 7 * Math.sin(angle), 0.5);
                rune.rotation.z = angle;
                frameGroup.add(rune);
            }

            scene.add(frameGroup);

            // Map surface
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            const grad = ctx.createRadialGradient(512, 512, 100, 512, 512, 550);
            grad.addColorStop(0, '#e8dcc8');
            grad.addColorStop(0.6, '#d4c4a8');
            grad.addColorStop(1, '#a89070');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 1024, 1024);

            for (let i = 0; i < 40000; i++) {
                ctx.fillStyle = `rgba(80, 60, 40, ${Math.random() * 0.08})`;
                ctx.fillRect(Math.random() * 1024, Math.random() * 1024, 1, 1);
            }

            ctx.fillStyle = 'rgba(50, 60, 50, 0.4)';
            ctx.beginPath(); ctx.ellipse(512, 280, 200, 150, 0, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = 'rgba(40, 70, 40, 0.3)';
            ctx.beginPath(); ctx.ellipse(250, 350, 100, 120, -0.2, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = 'rgba(80, 120, 150, 0.5)';
            ctx.beginPath(); ctx.ellipse(780, 450, 80, 120, 0.3, 0, Math.PI * 2); ctx.fill();

            ctx.strokeStyle = 'rgba(80, 60, 40, 0.5)';
            ctx.lineWidth = 6; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(512, 800); ctx.quadraticCurveTo(500, 600, 512, 450); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(512, 450); ctx.quadraticCurveTo(350, 400, 250, 350); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(512, 450); ctx.quadraticCurveTo(650, 420, 750, 450); ctx.stroke();

            const vig = ctx.createRadialGradient(512, 512, 250, 512, 512, 520);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(30, 25, 20, 0.6)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, 1024, 1024);

            const mapMesh = new THREE.Mesh(
                new THREE.SphereGeometry(4.2, 48, 48, 0, Math.PI * 2, 0, Math.PI * 0.48),
                new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(canvas), roughness: 0.75, side: THREE.DoubleSide })
            );
            mapMesh.position.set(5, 0, 0);
            mapMesh.scale.set(1, 1.3, 0.35);
            mapMesh.rotation.x = Math.PI;
            scene.add(mapMesh);
        }

        function createFloorRunes() {
            const runeGroup = new THREE.Group();
            runeGroup.position.set(3, -4.95, 4);
            runeGroup.rotation.x = -Math.PI / 2;

            const runeMat = new THREE.MeshBasicMaterial({ color: 0x334455, transparent: true, opacity: 0.3 });

            runeGroup.add(new THREE.Mesh(new THREE.RingGeometry(3, 3.2, 48), runeMat));
            runeGroup.add(new THREE.Mesh(new THREE.RingGeometry(1.8, 2, 48), runeMat));

            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const line = new THREE.Mesh(new THREE.PlaneGeometry(0.08, 1.2), runeMat);
                line.position.set(Math.cos(angle) * 2.5, Math.sin(angle) * 2.5, 0);
                line.rotation.z = angle + Math.PI / 2;
                runeGroup.add(line);
            }

            scene.add(runeGroup);
        }

        // Simple direct GLB loading (works outside Squarespace sandbox)
        function loadGLB(url, name) {
            return new Promise((resolve) => {
                gltfLoader.load(url,
                    (gltf) => {
                        console.log(`✓ ${name} loaded`);
                        loadedCount++;
                        updateLoader();
                        resolve(gltf);
                    },
                    (progress) => {
                        if (progress.total) {
                            const pct = Math.round((progress.loaded / progress.total) * 100);
                            document.getElementById('loader').textContent = `Loading ${name}... ${pct}%`;
                        }
                    },
                    (err) => {
                        console.error(`✗ ${name} failed:`, err);
                        loadedCount++;
                        updateLoader();
                        resolve(null);
                    }
                );
            });
        }

        function updateLoader() {
            const loader = document.getElementById('loader');
            if (loadedCount >= totalAssets && loader) {
                loader.style.opacity = 0;
                setTimeout(() => loader.remove(), 500);
            }
        }

        async function loadAllGLBs() {
            // VOLCANO
            const volcanoGltf = await loadGLB(ASSETS.volcano, 'Volcano');
            if (volcanoGltf) {
                const model = volcanoGltf.scene;
                model.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0x2a2018, roughness: 0.9 }); });
                model.scale.setScalar(0.5);
                model.position.set(0, 2.5, 0.5);
                model.rotation.x = 0.35;
                mapGroup.add(model);
                mapGroup.add(new THREE.PointLight(0xff4400, 0.8, 2).translateY(3.5).translateZ(0.3));
            }

            // TREES
            const treeGltf = await loadGLB(ASSETS.tree, 'Trees');
            if (treeGltf) {
                for (let i = 0; i < 6; i++) {
                    const tree = treeGltf.scene.clone();
                    tree.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0x3a4a3a, roughness: 0.9 }); });
                    tree.scale.setScalar(0.2 + Math.random() * 0.15);
                    tree.position.set(-2.5 + (Math.random() - 0.5) * 1.5, 2.5 + (Math.random() - 0.5) * 1.5, 0.4);
                    tree.rotation.set(0.3, Math.random() * Math.PI, 0);
                    mapGroup.add(tree);
                }
            }

            // COTTAGES
            const cottageGltf = await loadGLB(ASSETS.cottage, 'Cottages');
            if (cottageGltf) {
                for (let i = 0; i < 4; i++) {
                    const house = cottageGltf.scene.clone();
                    house.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.8 }); });
                    house.scale.setScalar(0.015);
                    house.position.set(-0.3 + (Math.random() - 0.5) * 1.5, -2.2 + (Math.random() - 0.5) * 0.8, 0.4);
                    house.rotation.set(0.2, Math.random() * Math.PI, 0);
                    mapGroup.add(house);
                }
            }

            // ROCKS
            const rockGltf = await loadGLB(ASSETS.rock, 'Rocks');
            if (rockGltf) {
                const model = rockGltf.scene;
                model.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0x555566, roughness: 0.85 }); });
                model.scale.setScalar(0.4);
                model.position.set(2, 0.5, 0.4);
                model.rotation.x = 0.25;
                mapGroup.add(model);
            }

            // ICE
            const iceGltf = await loadGLB(ASSETS.ice, 'Ice');
            if (iceGltf) {
                const model = iceGltf.scene;
                model.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0xaaddff, roughness: 0.15, transparent: true, opacity: 0.85 }); });
                model.scale.setScalar(0.35);
                model.position.set(2.2, 3, 0.4);
                model.rotation.x = 0.3;
                mapGroup.add(model);
            }

            // TOWER
            const towerGltf = await loadGLB(ASSETS.tower, 'Tower');
            if (towerGltf) {
                const model = towerGltf.scene;
                model.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.85 }); });
                model.scale.setScalar(0.08);
                model.position.set(1.5, -1.8, 0.4);
                model.rotation.x = 0.2;
                mapGroup.add(model);
            }
        }

        function addMapLabels() {
            const labels = [
                { text: "The Dark White Woods", x: -2.5, y: 4, z: 1 },
                { text: "Gate of the North Pole", x: 2.2, y: 4, z: 1 },
                { text: "Moimola Mountain", x: 0, y: 3.2, z: 1.2 },
                { text: "The Mines", x: 2.2, y: 0.8, z: 1 },
                { text: "Lake Marinela", x: 2.8, y: -1, z: 1 },
                { text: "Orphanage", x: 0, y: -1.5, z: 1 },
                { text: "Outtown Roads", x: -2, y: -0.5, z: 1 },
                { text: "Town of New Wonders", x: 0, y: -3.5, z: 1 }
            ];

            labels.forEach(l => {
                const div = document.createElement('div');
                div.className = 'map-label';
                div.textContent = l.text;
                const obj = new CSS3DObject(div);
                obj.position.set(5 + l.x, l.y, l.z);
                obj.scale.setScalar(0.01);
                scene.add(obj);
            });
        }

        function initSnow() {
            const canvas = document.getElementById('snow-overlay');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = Array.from({ length: 80 }, () => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                r: Math.random() * 2 + 0.5,
                vx: (Math.random() - 0.5) * 0.4,
                vy: Math.random() * 0.8 + 0.3,
                alpha: Math.random() * 0.4 + 0.2
            }));

            (function animateSnow() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(200, 220, 255, ${p.alpha})`;
                    ctx.fill();
                    p.x += p.vx; p.y += p.vy;
                    if (p.y > canvas.height) { p.y = -5; p.x = Math.random() * canvas.width; }
                    if (p.x < 0) p.x = canvas.width;
                    if (p.x > canvas.width) p.x = 0;
                });
                requestAnimationFrame(animateSnow);
            })();

            window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
            cssRenderer.render(scene, camera);
        }
    </script>
</body>
</html>
